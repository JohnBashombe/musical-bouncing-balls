<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Musical Bouncing Balls - Collision Removal</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #111;
        overflow: hidden;
        height: 100%;
    }
    canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
    }
    #backgroundText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 10vw;
        color: rgba(255, 255, 255, 0.03);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.03);
        white-space: nowrap;
        pointer-events: none;
        z-index: 0;
        user-select: none;
    }
    #endText {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 5vw;
        color: white;
        z-index: 2;
        display: none;
    }
</style>
</head>
<body>
<div id="backgroundText">Klassik Details</div>
<div id="endText">End of Animation</div>
<canvas id="ballCanvas"></canvas>

<script>
const canvas = document.getElementById("ballCanvas");
const ctx = canvas.getContext("2d");
const endText = document.getElementById("endText");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

class Ball {
    constructor(x, y, radius, color, dx, dy) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.dx = dx;
        this.dy = dy;
    }
    draw() {
        ctx.beginPath();
        const gradient = ctx.createRadialGradient(this.x, this.y, this.radius/4, this.x, this.y, this.radius);
        gradient.addColorStop(0, "white");
        gradient.addColorStop(1, this.color);
        ctx.fillStyle = gradient;
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
    update() {
        this.x += this.dx;
        this.y += this.dy;

        if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
            this.dx *= -1;
        }
        if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
            this.dy *= -1;
        }

        this.draw();
    }
}

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playNote(frequency) {
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.value = frequency;
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.4);
}

const collisionNotes = [
    523.25, 587.33, 659.25, 698.46, 783.99, 880.00,
    987.77, 1046.50, 1174.66, 1318.51, 1396.91, 1567.98
];
let collisionIndex = 0;
function playCollisionSound() {
    playNote(collisionNotes[collisionIndex]);
    collisionIndex = (collisionIndex + 1) % collisionNotes.length;
}

function detectCollisions() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let dx = balls[i].x - balls[j].x;
            let dy = balls[i].y - balls[j].y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            let minDist = balls[i].radius + balls[j].radius;

            if (distance < minDist) {
                playCollisionSound();
                let survivor, removeIndex;
                if (balls[i].radius < balls[j].radius) {
                    survivor = balls[j];
                    removeIndex = i;
                } else if (balls[j].radius < balls[i].radius) {
                    survivor = balls[i];
                    removeIndex = j;
                } else {
                    if (Math.random() < 0.5) {
                        survivor = balls[j];
                        removeIndex = i;
                    } else {
                        survivor = balls[i];
                        removeIndex = j;
                    }
                }
                // Change survivor color and slightly increase size
                survivor.color = colors[Math.floor(Math.random() * colors.length)];
                survivor.radius *= 1.05;

                balls.splice(removeIndex, 1);
                if (balls.length === 1) {
                    endText.style.display = "block";
                }
                return;
            }
        }
    }
}

const colors = [
    "#ff4b5c", "#ffb400", "#1dd3b0", "#4a90e2", "#d16ba5", "#f6ae2d",
    "#9b5de5", "#00bbf9", "#00f5d4", "#f15bb5", "#fee440", "#00cecb"
];

let balls = [];
for (let i = 0; i < 100; i++) {
    let radius = 10 + Math.random() * 20;
    let x = Math.random() * (canvas.width - radius * 2) + radius;
    let y = Math.random() * (canvas.height - radius * 2) + radius;
    let dx = (Math.random() - 0.5) * 6;
    let dy = (Math.random() - 0.5) * 6;
    const color = colors[i % colors.length];
    balls.push(new Ball(x, y, radius, color, dx, dy));
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (balls.length > 1) {
        detectCollisions();
    }
    balls.forEach(ball => ball.update());
    requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
